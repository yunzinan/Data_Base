# 高级程序设计读书笔记
> 注: 电子书目录跳转+16页.

### 作用域机制
- 问题: 两个函数中定义同名的变量?
- 实际: 内部实体(如局部变量)的实现对外部是不可见的.

C++根据标识符的性质和它们的定义位置, 为每一个定义了的标识符规定了它的有效访范围---`作用域(scope)`.
> **常见报错**: xxx was not declared in this scope.

 标识符的作用域一方面对标识符的可见性进行限制, 另一方面也隐含着: 作用域不相交的两个标识符(标识不同实体)可以相同
 
 C++把标识符的作用域分为若干类, 其中包括: 
 - `局部作用域`
 - `全局作用域`
 - `文件作用域`
 - `函数作用域`
 - `函数原型作用域`
 - `命名空间作用域`
 - `类作用域`

#### 局部作用域 `local scope`
在`函数定义`或`复合语句`中, 从标识符的定义点到函数定义或复合语句结束之间的程序段.
> 注意: 局部作用域有时是一个潜在作用域. 需要扣除内部嵌套的同名实体.

> 不过这并不是良好的编程风格.

```c++
void f(){
    int x;
    ... x ...//外层的x
    while(...x...){//外层的x
        double x;
        ...x... // 内层的x
    }
   	...x... //外层的x
}
```
 
### 命名空间
- 问题: 在一个源文件中要用到两个分别在另外两个源文件中定义的不同的`全局程序实体`(如全局变量和函数),而这两个全局程序实体的名字相同.
> 想一想: 为什么要求是`全局程序实体`?
> ~函数/变量的作用域

    例如: 
    ```c++
    //file1.cpp
    void f(){
        
    }

    //file2.cpp
    void f(){
    
    }

    //main.cpp
    int main(){
    f();  // from file1.cpp
    f();  // from file2.cpp
    }
    ```
为了解决上述问题, c++提供了`命名空间机制`
    
